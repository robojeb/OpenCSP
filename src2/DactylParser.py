#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# CAVEAT UTILITOR
# This file was automatically generated by Grako.
#    https://bitbucket.org/apalala/grako/
# Any changes you make to it will be overwritten the
# next time the file is generated.
#

from __future__ import print_function, division, absolute_import, unicode_literals
from grako.parsing import * # @UnusedWildImport
from grako.exceptions import * # @UnusedWildImport

__version__ = '14.104.23.59.07'

class DactylParser(Parser):
    def __init__(self, whitespace=None, nameguard=True, **kwargs):
        super(DactylParser, self).__init__(whitespace=whitespace,
            nameguard=nameguard, **kwargs)

    @rule_def
    def _file_(self):
        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        self._assign_()
                    with self._option():
                        self._define_()
                    with self._option():
                        self._spawnop_()
                    self._error('no available options')
            self.ast['oper'] = self.last_node
            self._token(';')
        self._positive_closure(block0)

    @rule_def
    def _define_(self):
        self._name_()
        self.ast['n'] = self.last_node
        self._token('::=')
        self._program_()
        self.ast['p'] = self.last_node

    @rule_def
    def _assign_(self):
        self._name_()
        self.ast['n'] = self.last_node
        self._token(':=')
        self._expr_()
        self.ast['e'] = self.last_node

    @rule_def
    def _expr_(self):
        with self._choice():
            with self._option():
                self._exprAnd_()
                self.ast['e1'] = self.last_node
                self._token('||')
                self.ast['op'] = self.last_node
                self._expr_()
                self.ast['e2'] = self.last_node
            with self._option():
                self._exprAnd_()
                self.ast['e1'] = self.last_node
            self._error('no available options')

    @rule_def
    def _exprAnd_(self):
        with self._choice():
            with self._option():
                self._exprEq_()
                self.ast['e1'] = self.last_node
                self._token('&&')
                self.ast['op'] = self.last_node
                self._exprAnd_()
                self.ast['e2'] = self.last_node
            with self._option():
                self._exprEq_()
                self.ast['e1'] = self.last_node
            self._error('no available options')

    @rule_def
    def _exprEq_(self):
        with self._choice():
            with self._option():
                self._exprComp_()
                self.ast['e1'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('==')
                        with self._option():
                            self._token('!=')
                        self._error('expecting one of: == !=')
                self.ast['op'] = self.last_node
                self._exprEq_()
                self.ast['e2'] = self.last_node
            with self._option():
                self._exprComp_()
                self.ast['e1'] = self.last_node
            self._error('no available options')

    @rule_def
    def _exprComp_(self):
        with self._choice():
            with self._option():
                self._exprAdd_()
                self.ast['e1'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('>=')
                        with self._option():
                            self._token('<=')
                        with self._option():
                            self._token('>')
                        with self._option():
                            self._token('<')
                        self._error('expecting one of: > >= <= <')
                self.ast['op'] = self.last_node
                self._exprComp_()
                self.ast['e2'] = self.last_node
            with self._option():
                self._exprAdd_()
                self.ast['e1'] = self.last_node
            self._error('no available options')

    @rule_def
    def _exprAdd_(self):
        with self._choice():
            with self._option():
                self._exprMul_()
                self.ast['e1'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('+')
                        with self._option():
                            self._token('-')
                        self._error('expecting one of: + -')
                self.ast['op'] = self.last_node
                self._exprAdd_()
                self.ast['e2'] = self.last_node
            with self._option():
                self._exprMul_()
                self.ast['e1'] = self.last_node
            self._error('no available options')

    @rule_def
    def _exprMul_(self):
        with self._choice():
            with self._option():
                self._exprUni_()
                self.ast['e1'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('*')
                        with self._option():
                            self._token('/')
                        self._error('expecting one of: * /')
                self.ast['op'] = self.last_node
                self._exprMul_()
                self.ast['e2'] = self.last_node
            with self._option():
                self._exprUni_()
                self.ast['e1'] = self.last_node
            self._error('no available options')

    @rule_def
    def _exprUni_(self):
        with self._choice():
            with self._option():
                self._token('!')
                self.ast['op'] = self.last_node
                self._exprParen_()
                self.ast['e1'] = self.last_node
            with self._option():
                self._exprParen_()
                self.ast['e1'] = self.last_node
            self._error('no available options')

    @rule_def
    def _exprParen_(self):
        with self._choice():
            with self._option():
                self._token('(')
                self._expr_()
                self.ast['e1'] = self.last_node
                self._token(')')
            with self._option():
                self._value_()
                self.ast['e1'] = self.last_node
            self._error('no available options')

    @rule_def
    def _value_(self):
        with self._choice():
            with self._option():
                self._number_()
            with self._option():
                self._string_()
            with self._option():
                self._name_()
            self._error('no available options')

    @rule_def
    def _int_(self):
        self._pattern(r'[0-9]+')
        self.ast['num'] = self.last_node

    @rule_def
    def _number_(self):
        with self._choice():
            with self._option():
                self._int_()
                self._token('.')
                self._int_()
            with self._option():
                self._int_()
            self._error('no available options')

    @rule_def
    def _string_(self):
        self._pattern(r'"(?:[^"\\]|\\.)*"')

    @rule_def
    def _identifier_(self):
        self._pattern(r'[a-zA-Z_]+[a-zA-Z0-9_]*')

    @rule_def
    def _name_(self):
        with self._choice():
            with self._option():
                self._identifier_()
                self.ast['ident'] = self.last_node
                self._token('<')
                self._parameters_()
                self.ast['param'] = self.last_node
                self._token('>')
            with self._option():
                self._identifier_()
                self.ast['ident'] = self.last_node
            self._error('no available options')

    @rule_def
    def _parameters_(self):
        with self._choice():
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._expr_()
                        with self._option():
                            self._range_()
                        self._error('no available options')
                self._token(',')
                self._parameters_()
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._expr_()
                        with self._option():
                            self._range_()
                        self._error('no available options')
            self._error('no available options')

    @rule_def
    def _program_(self):
        self._token('[')
        self._sequence_()
        self.ast['s'] = self.last_node
        self._token(']')

    @rule_def
    def _sequence_(self):
        def block0():
            with self._group():
                with self._choice():
                    with self._option():
                        self._assign_()
                    with self._option():
                        self._ifblk_()
                    with self._option():
                        self._loop_()
                    self._error('no available options')
            self.ast['oper'] = self.last_node
            self._token(';')
        self._closure(block0)

    @rule_def
    def _ifblk_(self):
        self._token('[')
        self._branches_()
        self._token(']')

    @rule_def
    def _loop_(self):
        self._token('*[')
        self._branches_()
        self._token(']')

    @rule_def
    def _branches_(self):
        self._branch_()
        self.ast['b1'] = self.last_node
        def block1():
            self._token('|')
            self._branch_()
            self.ast['bl'] = self.last_node
        self._closure(block1)

    @rule_def
    def _branch_(self):
        self._expr_()
        self.ast['cond'] = self.last_node
        self._token('->')
        self._sequence_()
        self.ast['op'] = self.last_node

    @rule_def
    def _semdef_(self):
        self._token('semaphore(')
        self._expr_()
        self._token(')')

    @rule_def
    def _semop_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('P')
                with self._option():
                    self._token('V')
                self._error('expecting one of: V P')
        self._token('(')
        self._name_()
        self._token(')')

    @rule_def
    def _spawnop_(self):
        self._token('spawn(')
        self._name_()
        self.ast['n'] = self.last_node
        self._token(')')

    @rule_def
    def _range_(self):
        self._token('[')
        self._int_()
        self._token(',')
        self._int_()
        self._token(']')



class DactylSemanticParser(CheckSemanticsMixin, DactylParser):
    pass


class DactylSemantics(object):
    def file(self, ast):
        return ast

    def define(self, ast):
        return ast

    def assign(self, ast):
        return ast

    def expr(self, ast):
        return ast

    def exprAnd(self, ast):
        return ast

    def exprEq(self, ast):
        return ast

    def exprComp(self, ast):
        return ast

    def exprAdd(self, ast):
        return ast

    def exprMul(self, ast):
        return ast

    def exprUni(self, ast):
        return ast

    def exprParen(self, ast):
        return ast

    def value(self, ast):
        return ast

    def int(self, ast):
        return ast

    def number(self, ast):
        return ast

    def string(self, ast):
        return ast

    def identifier(self, ast):
        return ast

    def name(self, ast):
        return ast

    def parameters(self, ast):
        return ast

    def program(self, ast):
        return ast

    def sequence(self, ast):
        return ast

    def ifblk(self, ast):
        return ast

    def loop(self, ast):
        return ast

    def branches(self, ast):
        return ast

    def branch(self, ast):
        return ast

    def semdef(self, ast):
        return ast

    def semop(self, ast):
        return ast

    def spawnop(self, ast):
        return ast

    def range(self, ast):
        return ast

def main(filename, startrule, trace=False):
    import json
    with open(filename) as f:
        text = f.read()
    parser = DactylParser(parseinfo=False)
    ast = parser.parse(text, startrule, filename=filename, trace=trace)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import sys
    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in DactylParser.rule_list():
                print(r)
            print()
            sys.exit(0)
    parser = argparse.ArgumentParser(description="Simple parser for Dactyl.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(args.file, args.startrule, trace=args.trace)
